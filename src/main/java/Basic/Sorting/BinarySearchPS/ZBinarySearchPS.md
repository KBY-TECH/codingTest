## 이분탐색 PS

목차

[1.랜선 자르기](#1랜선-자르기) <br>
[2.특정 수의 개수 구하기](#2특정-수의-개수-구하기) <br>
[3.고정점 찾기](#3고정점-찾기) <br>
[4.공유기 설치](#4공유기-설치) <br>
[5.가사 검색](#5가사-검색) <br>



## 1.랜선 자르기

---
주어진 랜선을 k개만큼 잘라내기 위해 최대 몇 m씩 랜선을 자를 수있는지 출력하는 문제.

핵심 : 영식이가 가지고 있는 길이중 최대의 길이를 갖는 랜선을 기준으로 반씩 범위를 좁혀가면서 탐색하는 문제.
(*파라메트릭 서치 문제)


### *파라매트릭 서치
 : 최적화 문제를 결정 문제로 해결하는 기법.
- 원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제

#### EX)
- 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 문제이면 이진 탐색으로 결정문제의 범위를 좁혀가면서 해결.

## 2.특정 수의 개수 구하기

---
- N개의 원소가 주어진 수열이 오름차순으로 정렬되어 있을 때, 특정 수의 개수를 구하는 문제이다.
- 단 log n의 시간복잡도를 가져야 하는 조건이 있다.

핵심 : 특정 수보다 큰 수를 찾는 UpperBound 함수와 특정 수가 처음 위치하는 곳을 찾아 두 값을 뺴줌으로서 개수를 구했다.

```java
 static int lowerBound(int arr[],int target,int start,int end)
    {
        // 특정 수가 처음 출연하는 위치 찾기.
        while (start<end)
        {
            int mid=(start+end)/2;
            if(arr[mid]>=target) // 특정 수와 같거나 혹은 큰 수라면 end=mid 구간과 동일하게
                end=mid;
            else
                start=mid+1; //특정 수와 보다 작은 값이면 해당 위치는 mid+1;
        }
        return end;
    }

    static int upperBound(int arr[],int target,int start,int end)
    {
        // 특정 수 다음에 위치하는 큰 수 찾기.
        while (start<end)
        {
            int mid=(start+end)/2;
            if(arr[mid]>target) // 특정보다 크다면 end의 위치를 mid
                end=mid;
            else
                start=mid+1; //  특정 수와 같거나 작다면 start 위치를 mid+1  
        }
        return end;
    }
```


## 3.고정점 찾기

---
- 해당 위치의 index와 같이 같은 고정점을 찾는 문제이다.
- 이미 정렬은 되있는 상태이다.
<br>
  
핵심 :  해당 인덱스(중간점)와 값을 비교했을 때
- 해당 인덱스가 값보다 작다면 end를 mid-1로 옮긴다. 
    - 이미 정렬이 된 상태이기 때문에 그 다음 인덱스와 인덱스 값도 같지 않을 것이다.
- 해당 인덱스가 값보다 크다면 start를 mid+1로 옮긴다.
    - 이미 정렬이 된 상태이기 떄문에 그 전 인덱스와 인덱스 값 또한 클 것이다.
  

## 4.공유기 설치

---
- 집이 N개가 있을 때 공유기 C개를 설치하는 문제.
- 단 공유기 간 거리를 최대로 할 때 공유기 C개를 설치하는 문제.

핵심 : 두 공유기 사이의 거리를 일일히 대입해 보는 것이 아닌 이분 탐색으로 범위를 좁혀가며 탐색. 
- 두 공유기 사이의 거리의 최댓값을 탐색해야 하는 문제로 볼 수 있다. (파라매트릭 서치)
- 공유기는 같은 위치에 위치할 수 없으므로 최소 거리는 1이고 최대 거리는 주어진 배열을 정렬하여 끝값에서 첫값을 빼준다.
- 해당 공유기는 처음 위치부터 설치한다고 가정하고 첫 공유기 설치 개수는 1이다.
- 해당 공유기의 중간 값은 인접한 공유기의 거리이므로 설치된 공유기 위치 + mid(Interval)로 각 배열의 값을 체크한다.
```java
 int mid=(start+end)/2;
            int interval=arr[0];
            int cnt=1;
            for (int i = 1; i <n ; i++) {
                if(arr[i]>=interval+mid)
                {
                    interval=arr[i];
                    cnt++;
                }
            }
```


##5.가사 검색

---
가사에 사용되는 키워드들이 words[]라는 배열에 있고 
입력으로 주어질 ("?" -> 와일드카드가 포함된 )단어가 있을 때 
키워드들과 일치하는 문자열들의 개수를 출력하는 문제.

핵심 : 
- 쿼리문의 길이* 각 문자열의 문자 하나하나 비교한다면 1억을 초과하기 때문에 탐색의 범위를 줄여주는 것이 핵심이다.
-  접두사,접미사 (와일드 카드 "?" 앞에,뒤에) 


<br>

- 각 문자열 길이별 리스트를 보관하고 입력으로 주어지는 쿼리문의 길이에 따라 이분 검색을 한다.
- 접두사에서 와일드 카드가 있을 떄를 대비해 문자들도 뒤집어서 따로 보관한다.
- lowwerBound, UpperBound 로 첫 일치하는 단어와 일치하지 않는 단어의 시작점의 차이를 구하면 개수가 나온다.
- lowerBound 에서 와일드카드 존재시 "?" -> "a" 로 대체한다. 모든 단어는 영단어 이고 문자열의 정렬상 가장 앞쪽에 위치한다.
- UpperBound 에서 와일드카드 존재시 "?" -> "z" 로 대체한다. 모든 단어는 영단어 이고 문자열의 정렬상 가장 뒤쪽에 위치한다.

#### String.compareTo()
- 문자열중 한 문자가 다르면 아스키 코드 값으로 비교하고 음수가 나온다면 기준이 되는 단어는 비교하고자 하는 대상의 앞쪽에 위치한다. (사전순 앞쪽)
- 양수가 나온다면 기준이 되는 단어는 비교하고자 하는 대상의 뒤쪽에 위치한다. (사전순 뒤쪽)



