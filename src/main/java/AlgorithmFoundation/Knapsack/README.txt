Knapsack DynammicProgramming
        입력
        첫째 줄에 물품의 수 N와 가방이 버틸 수 있는 무게 K를 입력후
        둘쨰 줄에는  N개의 줄에 거쳐 각 물건의 무게 W와 해당 물건의 가치를 입력합니다.


        무게는 w[]에, 가치는 p[]에는 가치를 저장합니다.
        dp[i][j]: i번째 물건을 가져오는 중이며, 탐색해서 담은 무게합이 j일 때, 최대 가치를 저장합니다.
        dp[i][j]에 들어갈 수 있는 경우는, i번째 무게를 넣거나 넣지 않는 경우의 수입니다.
            넣지 않을 때에는 i-1번째 무게까지의 누적값을 가져오되 현재 무게 합이 j인 경우를 확인하고 있으므로 dp[i-1][j]에 값을 변경합니다.
            i를 넣는 경우 일 떄에는 i-1까지의 누적된 값 중 현재 i를 넣어 무게 j를 만들 것이므로
                지금까지의 저장한 무게 j에서 i를 넣기 위해 i의 무게를 뺀 나머지 무게를 가치를 써야하므로
                그 가치와 i의 가치를 합칩니다.
        이 두가지 경우 중 하나를 선택하여 최댓값을 dp에 배열에 삽입하면 넣으면 됩니다.

Knapsack BackTracking
 입력: 아이템의 개수 n와 가방의 제한적인 무게 W을 입력후
        각 n개의 아이템의 무게와 가치를 입력합니다(가치가 내림차순으로 입력되어야 합니다)
   knapsack에서 무게가 충분하고 maxprofit보다 크면 지금 정보를 저장하고 그다음으로 promising하다면
     1)해당 include 배열에 있는 것이 true로 바뀌며 다음 아이템을 포함시킵니다.
     2)해당 include 배열에 있는 것이 false로 바뀌며 다음 아이템을 포함시키지 않습니다.


Knapsack Branch of bound
   입력: 해당 각 아이템 항목의 w와 profit 그리고 index 순서(Path를 저장하기 위한 것)를 차례대로 넣어주며 노드를 생성 합니다.
        그 후 knapsack 이라는 함수가 호출됩니다. 해당 입력은 아이템의 개수 N과 Weight은 고정 값으로 해놓았으며 전역변수로 선언하여 따로
        함수에 대한 인자로 삽입을 하지 않았습니다.
   출력: 출력은 해당 최적의 아이템들의 정보를 출력합니다. 그리고 최대 Profit을 출력합니다.




